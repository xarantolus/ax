import { join } from "path";
import { copyFileSync, readFileSync, unlinkSync, writeFileSync } from "fs";
import { buildDocumentation, DocEntry, DocEntryConstructor, generateDocumentation } from 'tsdoc-markdown';
import assert from "assert";

// Interestingly, tsdoc doesn't generate anything if it's a .d.ts file, but a .ts file works perfectly fine.
// We just copy the file to a .ts file and then delete it after the docs are generated.
let entrypoint = join(__dirname, '../../pkg/ax_x86.d.ts');

let entrypointTs = entrypoint.replace(/\.d\.ts$/, '.ts');
copyFileSync(entrypoint, entrypointTs);
process.on('exit', () => {
	try {
		unlinkSync(entrypointTs);
	} catch (e) {
		// ignore
	}
});

let documentation = buildDocumentation({
	inputFiles: [entrypointTs],
});


let fileContent = readFileSync(entrypointTs, 'utf8').toString();
function extractEnum(name: string): { content: string, docs: string } {
	// Extract something like the next 5 lines:
	// /**
	// * Syscalls that can be registered for automatic handling
	// * Some multiline
	// */
	// export enum Syscall {
	// 	Exit,
	// }

	// Find the export enum line -- don't use regex
	let start = fileContent.indexOf(`export enum ${name}`);
	if (start === -1) {
		throw new Error(`Could not find enum ${name}`);
	}

	// Find the first line above , /**
	let docsStart = fileContent.lastIndexOf('/**', start);
	if (docsStart === -1) {
		throw new Error(`Could not find docs for enum ${name}`);
	}
	// find the closing */
	let docsEnd = fileContent.indexOf('*/', docsStart);
	if (docsEnd === -1) {
		throw new Error(`Could not find docs for enum ${name}`);
	}

	// Find the first line below }, and remove the last line
	let end = fileContent.indexOf('}', start) + 1;
	if (end === -1) {
		throw new Error(`Could not find end of enum ${name}`);
	}

	// Now remove the "*" and "/**" from start of each line
	let docs = fileContent.substring(docsStart, docsEnd)
		.split('\n')
		.map(line => line.trim().replace(/^\/\*\*?/, '').trim().replace(/\*\/$/, '').trim())
		.map(line => line.replace(/^(\*| )/, '').trim())
		.join('\n').trim()

	let content = fileContent.substring(start, end).trim();

	return { content, docs };
}

let functions = documentation.filter(m => m.doc_type === 'function');

let axecutor = documentation.find(m => m.doc_type === 'class' && m.name === 'Axecutor');
if (!axecutor) {
	throw new Error('Could not find Axecutor class');
}

let markdown = `# ax-x86 documentation
<!-- This file is generated by \`make docs\` and should not be edited manually. -->
The following documentation is generated from the generated TypeScript code.
`

function insertEnum(name: string, lvl = 4) {
	let { content, docs } = extractEnum(name);
	markdown += `${'#'.repeat(lvl)} ${name}
${docs}


\`\`\`ts
${content}
\`\`\`

`;
}

markdown += `## ${axecutor.name} class
${axecutor.documentation}

`;

function constructorType(obj: DocEntryConstructor) {
	let params = obj.parameters?.length ? obj.parameters!.map(p => `${p.name}: ${p.type}`).join(', ') : '';
	return `(${params}) => ${obj.returnType}`;
}


assert(axecutor.constructors?.length == 1, 'Expected exactly one constructor');
let constructor = axecutor.constructors![0];
markdown += `### Constructors
You can create an Axecutor either from x86-64 code bytes or from an ELF binary.

#### \`new Axecutor${constructorType(constructor)}\`
${constructor.documentation}

`;

function logNoDocs(name: string) {
	console.warn(`Warning: No documentation for ${name}`);
}

function generateMethods(methods: DocEntry[], title_prefix = '', lvl = 3) {
	for (let method of methods) {
		markdown += `${'#'.repeat(lvl)} \`${title_prefix}${method.name}${method.type}\`
${(method.documentation?.trim() || logNoDocs(title_prefix + method.name + method.type) || 'No documentation available').replace(/\.$/, "") + "."}

`;
		markdown += "\n";
	}
}

let constructor_method = axecutor.methods!.filter(m => m.name.startsWith('from_'));
assert.ok(constructor_method.length > 0, 'Could not find any from_ methods');
generateMethods(constructor_method, 'Axecutor.', 4);

markdown += `### Methods
Several methods are available for interacting with registers, memory and hooks.

`;

markdown += `#### Execution
There are two ways to execute code: \`execute\` and \`step\`.

`;

let execute = axecutor.methods!.filter(m => m.name === 'execute' || m.name === 'step');
assert.ok(execute.length > 0, 'Could not find any execute or step methods');
generateMethods(execute, 'Axecutor.', 5);

markdown += `#### Registers
The following methods are available for interacting with registers.

`;

let registers = axecutor.methods!.filter(m => m.name.startsWith('reg_')).sort(
	// Compare by the number at the end of the method name, also put read before write
	(a, b) => {
		let a_num = parseInt(a.name.match(/\d+$/)![0]);
		let b_num = parseInt(b.name.match(/\d+$/)![0]);
		if (a_num !== b_num) {
			return a_num - b_num;
		}
		if (a.name.startsWith('reg_read')) {
			return -1;
		}
		if (b.name.startsWith('reg_read')) {
			return 1;
		}
		return 0;
	}
);

assert.ok(registers.length > 0, 'Could not find any reg_ or methods');
generateMethods(registers, 'Axecutor.', 5);

markdown += `#### Segment registers
The following methods are available for interacting with segment registers.

`;

let segments = axecutor.methods!.filter(m => m.name.endsWith('_fs') || m.name.endsWith('_gs'));
assert.ok(segments.length > 0, 'Could not find any _fs methods');
generateMethods(segments, 'Axecutor.', 5);

markdown += `#### Memory
The following methods are available for interacting with memory.

`;

let stackInit = axecutor.methods!.filter(m => m.name.startsWith('init_stack'));
assert.ok(stackInit.length > 0, 'Could not find any stack_init methods');
generateMethods(stackInit, 'Axecutor.', 5);


let memoryInit = axecutor.methods!.filter(m => m.name.startsWith('mem_init') || m.name.startsWith('mem_resize_section'));
assert.ok(memoryInit.length > 0, 'Could not find any mem_init methods');
let memoryReadWriteSizes = axecutor.methods!.filter(m => /mem_(?:read|write)_\d+/.test(m.name) && !m.name.startsWith('mem_init'))
	.sort(
		// Compare by the number at the end of the method name, also put read before write
		(a, b) => {
			let a_num = parseInt(a.name.match(/\d+$/)![0]);
			let b_num = parseInt(b.name.match(/\d+$/)![0]);
			if (a_num !== b_num) {
				return a_num - b_num;
			}
			if (a.name.startsWith('mem_read')) {
				return -1;
			}
			if (b.name.startsWith('mem_read')) {
				return 1;
			}
			return 0;
		}
	);
assert.ok(memoryReadWriteSizes.length > 0, 'Could not find any mem_read/write methods');

let memory = [...memoryInit, ...memoryReadWriteSizes];
// Now add all mem_ we haven't added yet
memory = [...memory, ...axecutor.methods!.filter(m => m.name.startsWith('mem_') && !memory.includes(m))];

generateMethods(memory, 'Axecutor.', 5);

markdown += `#### Hooks
The following methods are available for hooks. Hooks are used to intercept execution of specific instructions.
They can either run before or after the instruction is executed. The callback function can be either synchronous or asynchronous and has the following signature:
\`\`\`ts
type Function = (instance: Axecutor, mnemonic: Mnemonic) => void | Promise<void>;
\`\`\`

`;

let hooks = axecutor.methods!.filter(m => m.name.startsWith('hook_'));
assert.ok(hooks.length > 0, 'Could not find any hook_ methods');
generateMethods(hooks, 'Axecutor.', 5);

markdown += `##### Hook return functions
One of the following methods *MUST* be returned from the hook callback function.

`;

let hookReturn = axecutor.methods!.filter(m => ["stop", "unchanged", "commit"].includes(m.name));
assert.ok(hookReturn.length > 0, 'Could not find any hook return methods');
generateMethods(hookReturn, 'Axecutor.', 6);

markdown += `### Syscalls
Some syscalls can be automatically handled.

`;

insertEnum('Syscall', 4);

let syscalls = axecutor.methods!.filter(m => m.name.startsWith('handle_syscalls'));
assert.ok(syscalls.length > 0, 'Could not find any handle_syscalls methods');
generateMethods(syscalls, 'Axecutor.', 4);


let all_functions = [...hooks, ...memory, ...segments, ...registers, ...constructor_method, ...hookReturn, ...stackInit, ...execute, ...syscalls];

markdown += `### Other
There are also some utility methods.

`;

let other = axecutor.methods!.filter(m => !all_functions.includes(m));
generateMethods(other, 'Axecutor.', 4);

markdown += `## Functions
The following functions are available after the \`init\` function has been called.

`;

generateMethods(functions, '', 3);

markdown += `## Enums
The following enums are available.

`;

insertEnum('Mnemonic', 3);

insertEnum('Register', 3);

writeFileSync(join(__dirname, '../../api_doc.md'), markdown);
