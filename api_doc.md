# ax-x86 documentation
<!-- This file is generated by `make docs` and should not be edited manually. -->
The following documentation is generated from the generated TypeScript code.
## Axecutor class
Axecutor is the main struct that is used for emulation.

It can be instantiated in JavaScript using one of the following methods:
 - `let ax = new Axecutor(code: Uint8Array, code_start_addr: bigint, initial_rip: bigint)`
 - `let ax = Axecutor.fromBinary(elf_binary: Uint8Array)`.

Afterwards, one can register hooks before/after instructions:
 - `ax.hook_before_mnemonic(Mnemonic.Syscall, (axInstance: Axecutor) => {...});`
 - `ax.hook_after_mnemonic(Mnemonic.Syscall, (axInstance: Axecutor) => {...});`

### Constructors
You can create an Axecutor either from x86-64 code bytes or from an ELF binary.

#### `new Axecutor(code: Uint8Array, code_start_addr: bigint, initial_rip: bigint) => Axecutor`
Creates a new Axecutor instance from the given x86-64 instruction bytes, writing the code to memory at `code_start_addr` and setting the initial RIP to `initial_rip`.

#### `Axecutor.from_binary(binary: Uint8Array) => Axecutor`
Create a new Axecutor from the bytes of an ELF binary.
This will load the `.text` section into memory and set the program counter to the entry point.
One thing to note is that you might want to set up the stack via `init_stack_program_start` before running the binary.


### Methods
Several methods are available for interacting with registers, memory and hooks.

#### Execution
There are two ways to execute code: `execute` and `step`.

##### `Axecutor.execute() => Promise<void>`
Execute all instructions until execution has stopped.
Execution might stop due to hooks stopping emulation via the stop() method, execution reaching the end of the code, or an error.
This is the same as calling `step` in a loop, but staying in WASM should be more efficient.


##### `Axecutor.step() => Promise<boolean>`
Execute the next instruction (including all registered hooks), returning if execution has stopped.


#### Registers
The following methods are available for interacting with registers.

##### `Axecutor.reg_read_8(reg: number) => bigint`
Reads an 8-bit value from a 8-bit wide register. Invalid registers lead to exceptions.


##### `Axecutor.reg_write_8(reg: number, value: bigint) => void`
Writes an 8-bit value to a 8-bit wide register. Out-of-range values or invalid registers lead to exceptions.


##### `Axecutor.reg_read_16(reg: number) => bigint`
Reads a 16-bit value from a 16-bit wide register. Invalid registers lead to exceptions.


##### `Axecutor.reg_write_16(reg: number, value: bigint) => void`
Writes a 16-bit value to a 16-bit wide register. Out-of-range values or invalid registers lead to exceptions.


##### `Axecutor.reg_read_32(reg: number) => bigint`
Reads a 32-bit value from a 32-bit wide register. Invalid registers lead to exceptions.


##### `Axecutor.reg_write_32(reg: number, value: bigint) => void`
Writes a 32-bit value to a 32-bit wide register. Out-of-range values or invalid registers lead to exceptions.
Note that on x86-64 writes to 32-bit registers clear the upper 32 bits of the corresponding 64-bit register.


##### `Axecutor.reg_read_64(reg: number) => bigint`
Reads a 64-bit value from a 64-bit wide register. Invalid registers lead to exceptions.


##### `Axecutor.reg_write_64(reg: number, value: bigint) => void`
Writes a 64-bit value to a 64-bit wide register. Out-of-range values or invalid registers lead to exceptions.


##### `Axecutor.reg_read_128(reg: number) => bigint`
Reads an 128-bit value from an 128-bit wide register. Invalid registers lead to exceptions.


##### `Axecutor.reg_write_128(reg: number, value: bigint) => void`
Writes an 128-bit value to an 128-bit wide register. Out-of-range values or invalid registers lead to exceptions.


#### Segment registers
The following methods are available for interacting with segment registers.

##### `Axecutor.read_fs() => bigint`
Reads the value of the FS segment register.


##### `Axecutor.read_gs() => bigint`
Reads the value of the GS segment register.


##### `Axecutor.write_fs(value: bigint) => void`
Writes a value to the FS segment register.


##### `Axecutor.write_gs(value: bigint) => void`
Writes a value to the GS segment register.


#### Memory
The following methods are available for interacting with memory.

##### `Axecutor.init_stack(length: bigint) => bigint`
Initializes the stack at a random location with the given length.


##### `Axecutor.init_stack_program_start(length: bigint, argv: any[], envp: any[]) => bigint`
Initializes the stack with the given length, command-line arguments and environment variables according to the System V ABI.
This is useful for emulating ELF binaries.


##### `Axecutor.mem_init_anywhere(data: Uint8Array, name?: string) => bigint`
Initialize a memory area with the given data at a random address.
The start address is returned.


##### `Axecutor.mem_init_area(start: bigint, data: Uint8Array) => void`
Initialize a memory area with the given data.


##### `Axecutor.mem_init_area_named(start: bigint, data: Uint8Array, name?: string) => void`
Initialize a memory area with the given data and name.
The name is used for logging and debugging purposes.


##### `Axecutor.mem_init_zero(start: bigint, length: bigint) => void`
Initialize a memory area with the given length.


##### `Axecutor.mem_init_zero_anywhere(length: bigint) => bigint`
Initialize a memory area of the given length at a random address.
The start address is returned.


##### `Axecutor.mem_init_zero_named(start: bigint, length: bigint, name: string) => void`
Initialize a memory area with the given length and name.


##### `Axecutor.mem_resize_section(start_addr: bigint, new_size: bigint) => void`
Resize the already existing section of memory with start address `start_addr` to `new_size`
The code section cannot be resized.


##### `Axecutor.mem_read_8(address: bigint) => bigint`
Reads an 8-bit value from memory at `address`.


##### `Axecutor.mem_write_8(address: bigint, data: bigint) => void`
Writes an 8-bit value to memory at `address`.


##### `Axecutor.mem_read_16(address: bigint) => bigint`
Reads a 16-bit value from memory at `address`.


##### `Axecutor.mem_write_16(address: bigint, data: bigint) => void`
Writes a 16-bit value to memory at `address`.


##### `Axecutor.mem_read_32(address: bigint) => bigint`
Reads a 32-bit value from memory at `address`.


##### `Axecutor.mem_write_32(address: bigint, data: bigint) => void`
Writes a 32-bit value to memory at `address`.


##### `Axecutor.mem_read_64(address: bigint) => bigint`
Reads a 64-bit value from memory at `address`.


##### `Axecutor.mem_write_64(address: bigint, data: bigint) => void`
Writes a 64-bit value to memory at `address`.


##### `Axecutor.mem_read_128(address: bigint) => bigint`
Reads an 128-bit value from memory at `address`.


##### `Axecutor.mem_write_128(address: bigint, data: bigint) => void`
Writes an 128-bit value to memory at `address`.


##### `Axecutor.mem_prot(section_start: bigint, prot: number) => void`
Set the access permissions of the memory area with the given start address.
The access permissions are a bitmask of `PROT_READ` (1), `PROT_WRITE` (2), and `PROT_EXEC` (4).
A value of 0 means no access.
By default, all memory areas are initialized with `PROT_READ | PROT_WRITE`.


##### `Axecutor.mem_read_bytes(address: bigint, length: bigint) => Uint8Array`
Reads `length` bytes from memory at `address`.


##### `Axecutor.mem_write_bytes(address: bigint, data: Uint8Array) => void`
Writes bytes of `data` to memory at `address`.


#### Hooks
The following methods are available for hooks. Hooks are used to intercept execution of specific instructions.
They can either run before or after the instruction is executed. The callback function can be either synchronous or asynchronous and has the following signature:
```ts
type Function = (instance: Axecutor, mnemonic: Mnemonic) => void | Promise<void>;
```

##### `Axecutor.hook_after_mnemonic(mnemonic: number, cb: Function) => void`
Register a function to be called after a mnemonic is executed.
The function will be called with the Axecutor object and mnemonic as arguments.
The function may be sync or async and *MUST* return the result of one of the following functions:
 - instance.commit(): Continue execution, keep data
 - instance.stop(): Stop execution, keep data
 - instance.unchanged(): Continue execution, but discard data changed in the hook
You can register multiple functions for the same mnemonic, the order of execution is however not defined.


##### `Axecutor.hook_before_mnemonic(mnemonic: number, cb: Function) => void`
Register a function to be called before a mnemonic is executed.
The function will be called with the Axecutor object and mnemonic as arguments.
The function may be sync or async and *MUST* return the result of one of the following functions:
 - instance.commit(): Continue execution, keep data
 - instance.stop(): Stop execution, keep data
 - instance.unchanged(): Continue execution, but discard data changed in the hook
You can register multiple functions for the same mnemonic, the order of execution is however not defined.


##### Hook return functions
One of the following methods *MUST* be returned from the hook callback function.

###### `Axecutor.commit() => any`
This function should be returned from a hook to indicate the state should be kept and execution should continue.


###### `Axecutor.stop() => any`
This function should be returned from a hook to indicate the state should be kept and execution should stop.
You can also call this function from ouside of a hook, it will however not stop any running hooks.


###### `Axecutor.unchanged() => any`
This function should be returned from a hook to indicate the state should *not* be kept, but execution should continue.


### Syscalls
Some syscalls can be automatically handled.

#### Syscall
Syscalls that can be registered for automatic handling


```ts
export enum Syscall {
  Brk = 12,
  Pipe = 22,
  Exit = 60,
  ArchPrctl = 158,
}
```

#### `Axecutor.handle_syscalls(...syscalls: any) => void`
Register syscalls that the emulator should handle automatically.
The function takes variadic arguments, where each argument is a number of one of the supported Syscalls.


### Other
There are also some utility methods.

#### `Axecutor.call_stack() => string`
Give an overview of the current call stack.
This works best when a symbol table has been provided, which is currently only the case for ELF binaries.


#### `Axecutor.free() => void`
No documentation available.


#### `Axecutor.resolve_symbol(addr: bigint) => string`
Get the symbol name for a given address. This only works if the ELF binary contains a symbol table.
If no symbol is found, None or undefined is returned.


#### `Axecutor.toString() => string`
Returns a string representation of the Axecutor instance that can be useful for debugging.


#### `Axecutor.trace() => string`
Generate a trace of the current execution state. This trace is a list of all executed jumps, calls and returns.
This works best when a symbol table has been provided, which is currently only the case for ELF binaries.


## Functions
The following functions are available after the `init` function has been called.

### `version() => string`
Returns the version of `ax`.


### `commit() => string`
Returns the commit hash of this `ax` version.


### `initSync(module: SyncInitInput) => InitOutput`
Instantiates the given `module`, which can either be bytes or
a precompiled `WebAssembly.Module`.


### `default(module_or_path?: InitInput | Promise<InitInput>) => Promise<InitOutput>`
If `module_or_path` is {RequestInfo} or {URL}, makes a request and
for everything else, calls `WebAssembly.instantiate` directly.


## Enums
The following enums are available.

### Mnemonic
All mnemonics supported by the emulator


```ts
export enum Mnemonic {
  Adc = 5,
  Add = 7,
  And = 21,
  Call = 59,
  Cdq = 61,
  Cdqe = 62,
  Cld = 66,
  Cmovae = 78,
  Cmove = 81,
  Cmovne = 86,
  Cmp = 93,
  Cpuid = 106,
  Cqo = 107,
  Cwd = 131,
  Dec = 137,
  Div = 138,
  Endbr64 = 152,
  Idiv = 276,
  Imul = 277,
  Inc = 279,
  Int = 287,
  Int1 = 288,
  Ja = 297,
  Jae = 298,
  Jb = 299,
  Jbe = 300,
  Je = 302,
  Jecxz = 303,
  Jg = 304,
  Jge = 305,
  Jl = 306,
  Jle = 307,
  Jmp = 308,
  Jne = 310,
  Jno = 311,
  Jnp = 312,
  Jns = 313,
  Jo = 314,
  Jp = 315,
  Jrcxz = 316,
  Js = 317,
  Lea = 374,
  Mov = 414,
  Movd = 418,
  Movsxd = 451,
  Movups = 453,
  Movzx = 454,
  Mul = 456,
  Neg = 464,
  Nop = 465,
  Not = 466,
  Pop = 590,
  Push = 640,
  Ret = 662,
  Setb = 688,
  Sete = 690,
  Setne = 695,
  Shl = 712,
  Shr = 715,
  Sub = 740,
  Syscall = 746,
  Test = 751,
  Xor = 1518,
  Xorps = 1520,
  Int3 = 1620,
}
```

### Register
All registers supported by the emulator


```ts
export enum Register {
  RIP = 0,
  RAX = 1,
  RBX = 2,
  RCX = 3,
  RDX = 4,
  RSI = 5,
  RDI = 6,
  RSP = 7,
  RBP = 8,
  R8 = 9,
  R9 = 10,
  R10 = 11,
  R11 = 12,
  R12 = 13,
  R13 = 14,
  R14 = 15,
  R15 = 16,
  EIP = 17,
  EAX = 18,
  EBX = 19,
  ECX = 20,
  EDX = 21,
  ESI = 22,
  EDI = 23,
  ESP = 24,
  EBP = 25,
  R8D = 26,
  R9D = 27,
  R10D = 28,
  R11D = 29,
  R12D = 30,
  R13D = 31,
  R14D = 32,
  R15D = 33,
  AX = 34,
  BX = 35,
  CX = 36,
  DX = 37,
  SI = 38,
  DI = 39,
  SP = 40,
  BP = 41,
  R8W = 42,
  R9W = 43,
  R10W = 44,
  R11W = 45,
  R12W = 46,
  R13W = 47,
  R14W = 48,
  R15W = 49,
  AH = 50,
  AL = 51,
  BH = 52,
  BL = 53,
  CH = 54,
  CL = 55,
  DH = 56,
  DL = 57,
  SIL = 58,
  DIL = 59,
  SPL = 60,
  BPL = 61,
  R8L = 62,
  R9L = 63,
  R10L = 64,
  R11L = 65,
  R12L = 66,
  R13L = 67,
  R14L = 68,
  R15L = 69,
  XMM0 = 70,
  XMM1 = 71,
  XMM2 = 72,
  XMM3 = 73,
  XMM4 = 74,
  XMM5 = 75,
  XMM6 = 76,
  XMM7 = 77,
  XMM8 = 78,
  XMM9 = 79,
  XMM10 = 80,
  XMM11 = 81,
  XMM12 = 82,
  XMM13 = 83,
  XMM14 = 84,
  XMM15 = 85,
}
```

